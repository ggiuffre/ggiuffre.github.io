<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>State</title>
  <meta name="author" content="Giorgio Giuffrè">
  <meta name="description"
    content="Purely functional programs and artificial neural networks solve the same problem in two very different ways.">
  <meta name="keywords" content="state,stateful,stateless,neural,networks,functional,programming">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../main.css" type="text/css">
  <link rel="stylesheet" href="../article.css" type="text/css">
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "inLanguage": "en",
      "headline": "State",
      "abstract": "Purely functional programs and artificial neural networks solve the same problem in two very different ways.",
      "datePublished": "2020-11-27T12:36:00+01:00",
      "author": {
          "@type": "Person",
          "name": "Giorgio Giuffrè",
          "url": "https://ggiuffre.github.io/"
        }
    }
    </script>
</head>

<body>
  <header>
    <h1>State</h1>
  </header>

  <main>
    <article>
      <p>Functional programming and the use of artificial neural networks are two approaches to computation that
        might seem unrelated at first, but can be seen as two opposite solutions to the same problem.</p>

      <h2>Functional programming</h2>
      <p>Software engineers praise purely functional software because it's <strong>easy to read</strong>: you can
        understand a pure function by just reading it, without any need to worry about the context in which this
        function was declared, without having to worry about its <em>environment</em>. You don't need to have
        three other files open to understand what a pure function <code>f</code> is doing, because you can be
        sure that <code>f</code> doesn't use global variables (there are no global variables, only global
        constants) and you can be sure that all functions that <code>f</code> depends on are pure.</p>
      <p>Being easy to read, purely functional programs are also easier to parallelize than their imperative
        counterparts, and they are easier to optimize (you can cache the output of <code>f(3, 4)</code> for all
        future invocations of <code>f</code> that use those exact same inputs&mdash;<code>f</code> is
        deterministic, so it's going to give the same output anyway).</p>

      <p>Lastly, a purely functional program is easy to unit-test: all its units are pure functions, and as such
        can be tested without having to setup a certain state before calling a certain function.</p>

      <h2>ANNs</h2>
      <p>The weights of an ANN can be seen as its <strong>state</strong>.</p>
      <p>While functional programming is stateless, ANNs are dependent on state: here, in a certain sense,
        computation <em>is</em> state.</p>
      <p>ML Engineers often have to spend some effort into understanding what's happening in a neural network and
        why it is giving a certain output instead of another. This might be mostly due to the fact that ANNs are
        trained in a non-deterministic way, but is also due to the fact that ANNs depend so heavily on state:
        two networks with the same exact architecture but different state (different weights) can perform
        entirely dissimilar tasks. A three-layer feed-forward neural network can be trained to steer a small
        robot or to distinguish cats from dogs.</p>
      <p>So at least from an engineering point of view, a neural network is a black box. It is more meant to be
        used than to be understood. (Of course the engineer's point of view is different from the researcher's
        point of view&mdash;as much as the intentions of a Haskell programmer are different from a person who
        *maintains* Haskell and its compilers.)</p>
      <p>We were saying that neural networks are black boxes. Engineers praise these black boxes because they
        basically <em>write the algorithm for you</em>: if you want to calculate something for which you have
        tons of examples but no clear algorithm in mind, then just give these examples to a suitable ANN and
        store its state somewhere. This state (the weights of the network after it has been trained on the
        examples) <em>is</em> the computation needed to calculate what you want.</p>
      <p>So ANNs are the opposite of functional programming and yet they solve the same problem, the problem of
        <strong>computation</strong>: calculating an output, given some inputs.
      </p>

      <h2>Read-write</h2>
      <p>I would be tempted to say that an ANN is easier to write than to read, while a purely functional
        programming language is easier to read than to write. I'm not sure about this last statement (which is
        also not measurable anyway), but I'm gonna leave it here with the hope that someone can give me their
        thoughts on this.</p>

      <h2>Summary</h2>
      <p>To sum up:</p>
      <ul>
        <li>The problem of calculating an output given some inputs is known as the problem of computation.</li>
        <li>The problem of computation can be solved with different <strong>models of computation</strong>.</li>
        <li>Modern computer programs are perhaps best represented by purely functional programming. This
          approach suggests to first come up with a set of stateless computations, then apply the inputs to
          those computations to get an output.</li>
        <li>The approach of artificial neural networks suggests to first apply the inputs to a set of stateful
          computations, then adjust the state of the network so that the behavior of the network looks closer
          to a certain set of examples.</li>
        <li>There is some kind of symmetry in these two approaches.</li>
      </ul>
    </article>
  </main>

  <footer>
    <article id="home">
      <p>You can go <a href="..">back to the home page</a>.</p>
    </article>
  </footer>
</body>

</html>